# üõ¢ **Clase de SQL Nro 3**

### **Objetivo General:**

En esta clase, veremos los conceptos clave de SQL relacionados con consultas avanzadas, manipulaci√≥n de datos y funciones. Se enfocar√° en MySQL, aplicando ejemplos pr√°cticos para reforzar cada tema.

---

### **üïí Fundamentos Avanzados de Consultas SQL**

1. **Uni√≥n de Tablas**

   - üìñ **Concepto:** La uni√≥n de tablas permite combinar datos de m√∫ltiples tablas en una sola consulta.
   - üîç **Tipos de JOIN:**
     - `INNER JOIN`
     - `LEFT JOIN`
     - `RIGHT JOIN`
     - `FULL OUTER JOIN` _(No soportado en MySQL, se simula con UNION)_
   - ‚úÖ **Ejemplo Pr√°ctico:**

     ```sql
     CREATE TABLE cursos (
         id_curso INT PRIMARY KEY AUTO_INCREMENT,
         nombre_curso VARCHAR(50) NOT NULL
     );

     CREATE TABLE inscripciones (
         id_alumno INT,
         id_curso INT,
         PRIMARY KEY (id_alumno, id_curso),
         FOREIGN KEY (id_alumno) REFERENCES alumnos(id_alumno),
         FOREIGN KEY (id_curso) REFERENCES cursos(id_curso)
     );

     SELECT a.nombre, a.apellido, c.nombre_curso
     FROM alumnos a
     INNER JOIN inscripciones i ON a.id_alumno = i.id_alumno
     INNER JOIN cursos c ON i.id_curso = c.id_curso;
     ```

   - üí° **Aplicaci√≥n:** Obtener una lista de alumnos con los cursos en los que est√°n inscritos.

2. **Tipos de Datos en SQL**

   - üìñ **Concepto:** Diferencias entre `INT`, `VARCHAR`, `TEXT`, `DATE`, `DECIMAL`, etc.
   - ‚úÖ **Ejemplo de Creaci√≥n de Tabla con Distintos Tipos de Datos:**

     ```sql
     CREATE TABLE productos (
         id_producto INT PRIMARY KEY AUTO_INCREMENT,
         nombre VARCHAR(50) NOT NULL,
         precio DECIMAL(10,2) NOT NULL,
         fecha_ingreso DATE DEFAULT CURRENT_DATE
     );

     ```

---

## **Diferencia entre `VARCHAR` y `TEXT` en MySQL**

Ambos tipos de datos se utilizan para almacenar texto en MySQL, pero tienen diferencias importantes en cuanto a **almacenamiento, rendimiento y funcionalidad**.

---

## **üìå 1. `VARCHAR` (Variable Character)**

El tipo `VARCHAR(n)` almacena una cadena de longitud **variable**, donde `n` define la cantidad m√°xima de caracteres permitidos.

üìå **Caracter√≠sticas de `VARCHAR`:**  
‚úÖ **M√°ximo de 65,535 caracteres** (depende de la configuraci√≥n de la fila y el tama√±o de otras columnas).  
‚úÖ **Se almacena en la tabla misma** (en p√°ginas de datos).  
‚úÖ **Ocupa menos espacio si los valores son cortos**, ya que almacena solo la cantidad de caracteres ingresados m√°s 1 o 2 bytes adicionales para registrar la longitud.  
‚úÖ **M√°s r√°pido en b√∫squedas e √≠ndices** porque se puede indexar completamente.  
‚úÖ Se usa para **cadenas peque√±as o medianas** (como nombres, emails, direcciones).

üìå **Ejemplo de `VARCHAR`:**

```sql
CREATE TABLE usuarios (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(50),  -- M√°ximo 50 caracteres
    email VARCHAR(100)   -- M√°ximo 100 caracteres
);
```

üìå **C√≥mo MySQL almacena `VARCHAR(100)`:**

- Si guardamos `"Hola"`, ocupa **4 caracteres + 1 byte extra** = **5 bytes en total**.
- Si guardamos `"Hola, mundo"`, ocupa **11 caracteres + 1 byte extra** = **12 bytes en total**.

---

## **üìå 2. `TEXT` (Texto Largo)**

El tipo `TEXT` est√° dise√±ado para almacenar **grandes cantidades de texto** (hasta 4GB en versiones avanzadas).

üìå **Caracter√≠sticas de `TEXT`:**  
‚úÖ Puede almacenar **hasta 4GB de texto** dependiendo de la variante (`TINYTEXT`, `TEXT`, `MEDIUMTEXT`, `LONGTEXT`).  
‚úÖ **No se almacena en la tabla misma**, sino en un √°rea externa y solo se guarda un puntero.  
‚úÖ **No puede tener valores por defecto (`DEFAULT`)**.  
‚úÖ **Menos eficiente en consultas y filtrado**, porque no se indexa completamente.  
‚úÖ Se usa para **grandes cantidades de texto**, como descripciones, art√≠culos, comentarios de usuarios, etc.

üìå **Ejemplo de `TEXT`:**

```sql
CREATE TABLE articulos (
    id INT AUTO_INCREMENT PRIMARY KEY,
    titulo VARCHAR(255),
    contenido TEXT  -- Almacena grandes cantidades de texto
);
```

üìå **C√≥mo MySQL almacena `TEXT`:**

- Si guardamos `"Hola, mundo"`, ocupa **11 bytes**, pero el texto se almacena en un √°rea separada y la tabla solo guarda un puntero.

---

## **üìå 3. Diferencias Claves**

| Caracter√≠stica                      | `VARCHAR`                                                | `TEXT`                                                      |
| ----------------------------------- | -------------------------------------------------------- | ----------------------------------------------------------- |
| **Tama√±o M√°ximo**                   | Hasta **65,535** caracteres (depende del tama√±o de fila) | Hasta **4GB** en `LONGTEXT`                                 |
| **Almacenamiento**                  | En la tabla (m√°s r√°pido)                                 | Fuera de la tabla, con puntero                              |
| **Uso de √≠ndices**                  | **Se puede indexar completamente**                       | Solo se indexan los primeros **768 bytes**                  |
| **Uso de memoria**                  | M√°s eficiente para datos peque√±os                        | Ocupa m√°s espacio y requiere m√°s procesamiento              |
| **Valores por defecto (`DEFAULT`)** | ‚úÖ S√≠                                                    | ‚ùå No permitido                                             |
| **Mejor uso**                       | Para datos cortos y medianos (emails, nombres, t√≠tulos)  | Para grandes textos (art√≠culos, descripciones, comentarios) |

---

## **üìå 4. ¬øCu√°ndo usar `VARCHAR` y cu√°ndo usar `TEXT`?**

üîπ **Usa `VARCHAR` cuando...**  
‚úîÔ∏è Necesitas almacenar textos **relativamente cortos** (como nombres o direcciones).  
‚úîÔ∏è Quieres **indexar** la columna para b√∫squedas r√°pidas.  
‚úîÔ∏è Planeas hacer muchas **operaciones de filtrado y ordenamiento**.

üîπ **Usa `TEXT` cuando...**  
‚úîÔ∏è Vas a guardar **grandes cantidades de texto** (descripciones largas, art√≠culos, comentarios).  
‚úîÔ∏è No necesitas hacer **b√∫squedas exactas o ordenamiento frecuente** sobre la columna.

---

## **Diferencias entre los tipos de datos num√©ricos en MySQL**

En MySQL, los datos num√©ricos se dividen en **n√∫meros enteros** y **n√∫meros decimales (flotantes o de precisi√≥n fija)**. La elecci√≥n del tipo de dato adecuado depende del **rango de valores**, **precisi√≥n** y **uso de almacenamiento**.

---

## **üìå 1. Tipos de Datos Num√©ricos en MySQL**

| Tipo de Dato       | Bytes    | Rango de Valores (con signo)         | Rango de Valores (sin signo) | Soporta Decimales |
| ------------------ | -------- | ------------------------------------ | ---------------------------- | ----------------- |
| **TINYINT**        | 1        | -128 a 127                           | 0 a 255                      | ‚ùå No             |
| **SMALLINT**       | 2        | -32,768 a 32,767                     | 0 a 65,535                   | ‚ùå No             |
| **MEDIUMINT**      | 3        | -8,388,608 a 8,388,607               | 0 a 16,777,215               | ‚ùå No             |
| **INT / INTEGER**  | 4        | -2,147,483,648 a 2,147,483,647       | 0 a 4,294,967,295            | ‚ùå No             |
| **BIGINT**         | 8        | -9.2 cuatrillones a 9.2 cuatrillones | 0 a 18.4 cuatrillones        | ‚ùå No             |
| **DECIMAL (M, D)** | Variable | Definido por `M, D`                  | Definido por `M, D`          | ‚úÖ S√≠             |
| **FLOAT (M, D)**   | 4        | ‚âà ¬±3.4E-38 a ¬±3.4E+38                | ‚âà ¬±3.4E-38 a ¬±3.4E+38        | ‚úÖ S√≠             |
| **DOUBLE (M, D)**  | 8        | ¬±1.7E-308 a ¬±1.7E+308                | ¬±1.7E-308 a ¬±1.7E+308        | ‚úÖ S√≠             |

üìå **Nota:**

- `(M, D)`: `M` es la cantidad total de d√≠gitos y `D` es el n√∫mero de decimales.
- `UNSIGNED` significa que **solo admite valores positivos**, duplicando el rango positivo.

---

## **üìå 2. Tipos de N√∫meros Enteros (`TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, `BIGINT`)**

Los n√∫meros enteros se utilizan cuando **no se requieren decimales** y se deben elegir seg√∫n el rango de valores esperados.

### **Ejemplo de Uso**

```sql
CREATE TABLE usuarios (
    id INT AUTO_INCREMENT PRIMARY KEY,
    edad TINYINT UNSIGNED,  -- Valores entre 0 y 255
    puntos SMALLINT,        -- Valores entre -32,768 y 32,767
    ingresos BIGINT         -- Valores grandes (hasta cuatrillones)
);
```

üìå **¬øCu√°l usar?**  
‚úîÔ∏è **`TINYINT`**: Edad de una persona, estados binarios (1=Activo, 0=Inactivo).  
‚úîÔ∏è **`SMALLINT`**: Contador de productos, stock en almac√©n.  
‚úîÔ∏è **`MEDIUMINT`**: N√∫mero de visitas a una p√°gina.  
‚úîÔ∏è **`INT`**: ID de usuarios, conteo de registros en bases de datos grandes.  
‚úîÔ∏è **`BIGINT`**: N√∫meros muy grandes (ej. transacciones bancarias).

---

## **üìå 3. Tipos de N√∫meros Decimales (`DECIMAL`, `FLOAT`, `DOUBLE`)**

Se usan cuando se requiere **precisi√≥n en valores decimales**.

| Tipo de Dato       | Precisi√≥n                        | Uso                                            |
| ------------------ | -------------------------------- | ---------------------------------------------- |
| **DECIMAL (M, D)** | Alta precisi√≥n (almacena exacto) | Valores financieros, precios, tasas de inter√©s |
| **FLOAT (M, D)**   | Menos preciso, m√°s eficiente     | Gr√°ficos, mediciones cient√≠ficas               |
| **DOUBLE (M, D)**  | M√°s preciso que `FLOAT`          | C√°lculos cient√≠ficos, estad√≠sticas complejas   |

### **Ejemplo de Uso**

```sql
CREATE TABLE productos (
    id INT AUTO_INCREMENT PRIMARY KEY,
    precio DECIMAL(10,2),   -- Hasta 10 d√≠gitos, 2 decimales
    descuento FLOAT(5,2),   -- Aproximado, menos preciso
    valor_preciso DOUBLE(10,6) -- Mayor precisi√≥n
);
```

üìå **¬øCu√°l usar?**  
‚úîÔ∏è **`DECIMAL`**: Precios de productos, valores monetarios.  
‚úîÔ∏è **`FLOAT`**: Temperaturas, estad√≠sticas, valores cient√≠ficos.  
‚úîÔ∏è **`DOUBLE`**: C√°lculos matem√°ticos con alta precisi√≥n.

---

## **üìå 4. Diferencias Clave: `DECIMAL` vs `FLOAT` vs `DOUBLE`**

| Caracter√≠stica   | `DECIMAL`           | `FLOAT`           | `DOUBLE`                       |
| ---------------- | ------------------- | ----------------- | ------------------------------ |
| **Precisi√≥n**    | **Exacta**          | Aproximada        | Aproximada (mejor que `FLOAT`) |
| **Uso de Bytes** | Variable            | 4 bytes           | 8 bytes                        |
| **Aplicaci√≥n**   | Valores financieros | Datos cient√≠ficos | C√°lculos matem√°ticos complejos |

üìå **Ejemplo de Diferencia**

```sql
SELECT
    10.1 + 0.2 AS suma_decimal,
    CAST(10.1 AS FLOAT) + 0.2 AS suma_float;
```

‚úÖ **Salida:**  

| suma_decimal | suma_float |
|--------------|------------|
| **10.30** | **10.299999** |

üö® **Atenci√≥n**: `FLOAT` y `DOUBLE` pueden generar **errores de redondeo**. Para c√°lculos financieros, usa `DECIMAL`.

---

## **üìå 5. `SIGNED` vs `UNSIGNED` (Valores Positivos y Negativos)**

- **Por defecto, los enteros son `SIGNED`**, es decir, permiten valores negativos y positivos.
- **Si usas `UNSIGNED`**, el n√∫mero solo puede ser **positivo** y el rango **se duplica en valores positivos**.

### **Ejemplo de `SIGNED` y `UNSIGNED`**

```sql
CREATE TABLE ejemplo (
    valor_negativo SMALLINT SIGNED,  -- Rango: -32,768 a 32,767
    valor_positivo SMALLINT UNSIGNED -- Rango: 0 a 65,535
);
```

---

## **üìå 6. Elecci√≥n del Tipo de Dato Num√©rico Correcto**

| Caso de Uso                    | Tipo de Dato Recomendado |
| ------------------------------ | ------------------------ |
| Edad de una persona            | `TINYINT UNSIGNED`       |
| Cantidad de productos en stock | `SMALLINT` o `MEDIUMINT` |
| ID de usuario                  | `INT UNSIGNED`           |
| Precio de un producto          | `DECIMAL(10,2)`          |
| Descuento en porcentaje        | `FLOAT(5,2)`             |
| Transacciones bancarias        | `BIGINT UNSIGNED`        |
| Registro de temperatura        | `FLOAT`                  |
| C√°lculos cient√≠ficos complejos | `DOUBLE`                 |

---

## **üìå 7. Conclusi√≥n**

- **Usa n√∫meros enteros (`INT`, `BIGINT`, etc.)** cuando **no necesitas decimales**.
- **Usa `DECIMAL` para c√°lculos exactos** (ejemplo: dinero).
- **Usa `FLOAT` o `DOUBLE` si necesitas valores con decimales, pero puedes tolerar una ligera imprecisi√≥n**.
- **Siempre usa `UNSIGNED` si no necesitas valores negativos** para optimizar el almacenamiento.

---

## **Diferencia entre `DATE`, `DATETIME` y `TIMESTAMP` en MySQL**

En MySQL, estos tres tipos de datos se utilizan para almacenar informaci√≥n de fecha y hora, pero tienen diferencias importantes en cuanto a **rango, almacenamiento y comportamiento con zonas horarias**.

---

## **üìå 1. `DATE` (Solo Fecha)**

- Almacena **solo la fecha**, sin informaci√≥n de hora.
- Formato: `'YYYY-MM-DD'` (A√±o-Mes-D√≠a).
- Ocupa **3 bytes** en la base de datos.
- Rango de valores: **del `1000-01-01` al `9999-12-31`**.
- No depende de la zona horaria del servidor.

üìå **Ejemplo de `DATE`:**

```sql
CREATE TABLE empleados (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(50),
    fecha_nacimiento DATE
);

INSERT INTO empleados (nombre, fecha_nacimiento)
VALUES ('Carlos', '1995-06-15');

SELECT * FROM empleados;
```

‚úÖ **Salida esperada:**  

| id | nombre | fecha_nacimiento |
|----|--------|-----------------|
| 1 | Carlos | 1995-06-15 |

‚úÖ **Uso t√≠pico:** Fechas de nacimiento, eventos sin hora espec√≠fica, fechas de vencimiento.

---

## **üìå 2. `DATETIME` (Fecha y Hora Completa)**

- Almacena **fecha y hora** en formato completo.
- Formato: `'YYYY-MM-DD HH:MM:SS'` (A√±o-Mes-D√≠a Hora:Minuto:Segundo).
- Ocupa **8 bytes** en la base de datos.
- Rango de valores: **del `1000-01-01 00:00:00` al `9999-12-31 23:59:59`**.
- No se ajusta autom√°ticamente a la zona horaria del servidor.

üìå **Ejemplo de `DATETIME`:**

```sql
CREATE TABLE pedidos (
    id INT AUTO_INCREMENT PRIMARY KEY,
    cliente VARCHAR(50),
    fecha_pedido DATETIME
);

INSERT INTO pedidos (cliente, fecha_pedido)
VALUES ('Ana', '2025-03-22 14:30:00');

SELECT * FROM pedidos;
```

‚úÖ **Salida esperada:**  

| id | cliente | fecha_pedido |
|----|---------|----------------------|
| 1 | Ana | 2025-03-22 14:30:00 |

‚úÖ **Uso t√≠pico:** Registro de eventos exactos, fechas de creaci√≥n/modificaci√≥n de registros, programaci√≥n de tareas.

---

## **üìå 3. `TIMESTAMP` (Marca de Tiempo con Zona Horaria)**

- Similar a `DATETIME`, pero **se ajusta autom√°ticamente a la zona horaria** del servidor.
- Formato: `'YYYY-MM-DD HH:MM:SS'`.
- Ocupa **4 bytes** en la base de datos (m√°s eficiente que `DATETIME`).
- Rango de valores: **del `1970-01-01 00:00:01` al `2038-01-19 03:14:07`** (por la limitaci√≥n del formato UNIX Timestamp).
- Se usa com√∫nmente para registrar la fecha/hora de modificaciones de registros (`CURRENT_TIMESTAMP`).

üìå **Ejemplo de `TIMESTAMP`:**

```sql
CREATE TABLE logs (
    id INT AUTO_INCREMENT PRIMARY KEY,
    accion VARCHAR(100),
    fecha_log TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

INSERT INTO logs (accion) VALUES ('Usuario inici√≥ sesi√≥n');

SELECT * FROM logs;
```

‚úÖ **Salida esperada:**  

| id | accion | fecha_log |
|----|--------------------------|---------------------|
| 1 | Usuario inici√≥ sesi√≥n | 2025-03-22 10:45:30 |

‚úÖ **Uso t√≠pico:** Fechas de auditor√≠a, logs de actividad, marcas de tiempo en transacciones.

---

## **üìå 4. Comparaci√≥n de `DATE` vs `DATETIME` vs `TIMESTAMP`**

| Caracter√≠stica        | `DATE`                               | `DATETIME`                                    | `TIMESTAMP`                                   |
| --------------------- | ------------------------------------ | --------------------------------------------- | --------------------------------------------- |
| **Incluye Hora**      | ‚ùå No                                | ‚úÖ S√≠                                         | ‚úÖ S√≠                                         |
| **Formato**           | `'YYYY-MM-DD'`                       | `'YYYY-MM-DD HH:MM:SS'`                       | `'YYYY-MM-DD HH:MM:SS'`                       |
| **Bytes que ocupa**   | 3 bytes                              | 8 bytes                                       | 4 bytes                                       |
| **Rango de valores**  | `1000-01-01` a `9999-12-31`          | `1000-01-01 00:00:00` a `9999-12-31 23:59:59` | `1970-01-01 00:00:01` a `2038-01-19 03:14:07` |
| **Zona horaria**      | ‚ùå No depende de zona horaria        | ‚ùå No depende de zona horaria                 | ‚úÖ Se ajusta a la zona horaria del servidor   |
| **Valor por defecto** | ‚ùå No puede usar `CURRENT_TIMESTAMP` | ‚ùå No puede usar `CURRENT_TIMESTAMP`          | ‚úÖ `CURRENT_TIMESTAMP` por defecto            |

---

## **üìå 5. ¬øCu√°ndo usar cada uno?**

‚úÖ **Usa `DATE` cuando...**  
‚úîÔ∏è Solo necesitas la fecha sin la hora (fechas de nacimiento, vencimientos, eventos de un d√≠a).

‚úÖ **Usa `DATETIME` cuando...**  
‚úîÔ∏è Necesitas la fecha y la hora exacta, sin preocuparte por la zona horaria (horarios de reserva, citas m√©dicas).

‚úÖ **Usa `TIMESTAMP` cuando...**  
‚úîÔ∏è Necesitas registrar eventos con zona horaria ajustable (logs de actividad, fechas de modificaci√≥n de registros).

---

üöÄ **Conclusi√≥n:**

- **`DATE`**: Solo almacena fecha, ideal para datos sin hora.
- **`DATETIME`**: Fecha y hora fija, sin ajuste de zona horaria.
- **`TIMESTAMP`**: Similar a `DATETIME`, pero m√°s eficiente y ajustable a la zona horaria del servidor.

üìå **Ejemplo pr√°ctico:**  
Si tienes una tabla de productos en un e-commerce:

```sql
CREATE TABLE productos (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(100),  -- Corto y f√°cil de buscar
    descripcion TEXT       -- Puede ser un p√°rrafo largo
);
```

üîπ Aqu√≠ `nombre` es un **`VARCHAR(100)`** porque lo usar√°s para b√∫squedas.  
üîπ `descripcion` es un **`TEXT`** porque puede ser un texto largo y no necesitas filtrar por √©l.

---

üöÄ **Conclusi√≥n:**

- **Usa `VARCHAR` para datos peque√±os y medianos que necesitas buscar r√°pidamente.**
- **Usa `TEXT` para almacenar textos largos que no vas a indexar mucho.**

3. **Uso de LIKE y comodines**

   - üìñ **Concepto:** LIKE se usa para b√∫squedas flexibles en `VARCHAR` o `TEXT`.
   - üîç **Comodines:**
     - `%` (cualquier cantidad de caracteres)
     - `_` (un solo car√°cter)
     - `[ ]` (rango de caracteres en SQL Server)
   - ‚úÖ **Ejemplo de Aplicaci√≥n:**

     ```sql
     SELECT * FROM alumnos WHERE nombre LIKE 'A%'; -- Nombres que empiezan con "A"
     SELECT * FROM alumnos WHERE email LIKE '%@gmail.com'; -- Emails de Gmail
     ```

4. **Expresiones Regulares**

   - üìñ **Concepto:** En MySQL, `REGEXP` permite patrones m√°s complejos.
   - ‚úÖ **Ejemplo de Aplicaci√≥n:**

     ```sql
     SELECT * FROM alumnos WHERE email REGEXP '^[a-z]+@[a-z]+\\.(com|net)$';
     ```

## **Expresiones Regulares (REGEX) en MySQL**

Las **Expresiones Regulares (REGEX)** permiten realizar b√∫squedas avanzadas y validaciones de texto dentro de bases de datos. En MySQL, se usan con `REGEXP` y `RLIKE` para hacer comparaciones m√°s avanzadas que las que permite `LIKE`.

---

## **üìå 1. Uso de REGEXP en MySQL**

El operador `REGEXP` (o `RLIKE`, que es su sin√≥nimo) se usa para hacer comparaciones con patrones de texto.

### **Ejemplo b√°sico**

```sql
SELECT * FROM alumnos WHERE nombre REGEXP 'Alejandro|Juan';
```

üîπ **Busca alumnos cuyos nombres sean "Alejandro" o "Juan".**

### **Comparaci√≥n con LIKE**

| **M√©todo** | **Descripci√≥n**                                     | **Ejemplo**          | **Resultado**                |
| ---------- | --------------------------------------------------- | -------------------- | ---------------------------- |
| `LIKE`     | Busca coincidencias exactas con comodines `%` y `_` | `nombre LIKE 'A%'`   | Nombres que empiezan con "A" |
| `REGEXP`   | Permite patrones avanzados                          | `nombre REGEXP '^A'` | Nombres que empiezan con "A" |

---

## **üìå 2. Caracteres Especiales en REGEXP**

| **S√≠mbolo** | **Descripci√≥n**              | **Ejemplo**                                        |
| ----------- | ---------------------------- | -------------------------------------------------- | ------ | --------------------------------------- |
| `.`         | Cualquier car√°cter           | `'A.e'` (Coincide con "Ale", "Axe", etc.)          |
| `^`         | Inicio de la cadena          | `'^A'` (Empieza con "A")                           |
| `$`         | Fin de la cadena             | `'o$'` (Termina en "o")                            |
| ` | `                            | Alternativa (OR)                                   | `'Juan | Pedro'` (Coincide con "Juan" o "Pedro") |
| `[]`        | Grupo de caracteres          | `'[JPM]uan'` (Coincide con "Juan", "Puan", "Muan") |
| `[a-z]`     | Rango de letras min√∫sculas   | `'[a-d]'` (Coincide con "a", "b", "c" o "d")       |
| `[0-9]`     | Rango de n√∫meros             | `'[0-9]'` (Coincide con cualquier n√∫mero)          |
| `[^ ]`      | Negaci√≥n (NO este car√°cter)  | `'[^A]lejandro'` (No empieza con "A")              |
| `{n}`       | Repeticiones exactas         | `'[0-9]{3}'` (Exactamente 3 d√≠gitos)               |
| `{n,}`      | Al menos `n` repeticiones    | `'[0-9]{2,}'` (Al menos 2 d√≠gitos)                 |
| `{n,m}`     | Entre `n` y `m` repeticiones | `'[a-z]{2,5}'` (Entre 2 y 5 letras)                |

---

## **üìå 3. Ejemplos de Uso en MySQL**

### **1Ô∏è‚É£ Buscar nombres que comiencen con "J"**

```sql
SELECT * FROM alumnos WHERE nombre REGEXP '^J';
```

üîπ **Encuentra nombres como "Juan", "Julian", etc.**

### **2Ô∏è‚É£ Buscar nombres que terminen en "o"**

```sql
SELECT * FROM alumnos WHERE nombre REGEXP 'o$';
```

üîπ **Encuentra "Alejandro", "Marcelo", etc.**

### **3Ô∏è‚É£ Buscar nombres que contengan "an" en cualquier parte**

```sql
SELECT * FROM alumnos WHERE nombre REGEXP 'an';
```

üîπ **Encuentra "Juan", "Alejandra", etc.**

### **4Ô∏è‚É£ Buscar nombres que sean "Juan" o "Pedro"**

```sql
SELECT * FROM alumnos WHERE nombre REGEXP 'Juan|Pedro';
```

üîπ **Filtra registros con cualquiera de estos dos nombres.**

### **5Ô∏è‚É£ Buscar nombres con solo letras may√∫sculas**

```sql
SELECT * FROM alumnos WHERE nombre REGEXP '^[A-Z]+$';
```

üîπ **√ötil si queremos encontrar datos ingresados incorrectamente.**

### **6Ô∏è‚É£ Buscar n√∫meros de tel√©fono con exactamente 10 d√≠gitos**

```sql
SELECT * FROM alumnos WHERE telefono REGEXP '^[0-9]{10}$';
```

üîπ **Filtra tel√©fonos incorrectos o incompletos.**

---

## **üìå 4. Casos Pr√°cticos de REGEXP**

### ‚úÖ **Validaci√≥n de correos electr√≥nicos**

```sql
SELECT * FROM alumnos WHERE email REGEXP '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$';
```

üîπ **Encuentra solo correos electr√≥nicos v√°lidos.**

### ‚úÖ **Filtrar n√∫meros de DNI argentinos (entre 7 y 8 d√≠gitos)**

```sql
SELECT * FROM alumnos WHERE dni REGEXP '^[0-9]{7,8}$';
```

üîπ **√ötil para verificar DNIs correctamente ingresados.**

### ‚úÖ **Buscar alumnos con apellidos compuestos (con espacio o guion)**

```sql
SELECT * FROM alumnos WHERE apellido REGEXP '[- ]';
```

üîπ **Encuentra "De la Fuente", "Garc√≠a-M√°rquez", etc.**

---

## **üìå 5. Diferencias entre LIKE y REGEXP**

| Caracter√≠stica                   | `LIKE`                     | `REGEXP`                                      |
| -------------------------------- | -------------------------- | --------------------------------------------- | ------ |
| Uso de comodines                 | `%` y `_`                  | `.` `^` `$` `[]` ` | ` `{}` |
| B√∫squeda flexible                | Solo posiciones fijas      | Soporta patrones avanzados                    |
| Sensible a may√∫sculas/min√∫sculas | ‚úÖ (depende del collation) | ‚úÖ (sensible, pero configurable con `BINARY`) |
| Soporta rangos y repeticiones    | ‚ùå No                      | ‚úÖ S√≠                                         |

üîπ **¬øCu√°ndo usar `LIKE`?**  
‚úîÔ∏è Cuando necesitas b√∫squedas simples (ej. nombres que contienen "Juan").

üîπ **¬øCu√°ndo usar `REGEXP`?**  
‚úîÔ∏è Cuando necesitas validar formatos o hacer b√∫squedas m√°s avanzadas.

---

### ‚ùå **Error en la sintaxis de `LIKE` en MySQL**  

Las consultas que escribiste usan **rangos de caracteres `[A-B]` y negaciones `[^DV]`**, pero **esto no es compatible con `LIKE` en MySQL**.  

‚úÖ **En MySQL, debes usar `REGEXP` en lugar de `LIKE`** para estos casos.  

---

## **üìå Conversi√≥n de tus consultas a MySQL (`REGEXP`)**  

### **1Ô∏è‚É£ Buscar alumnos cuyos nombres comiencen con "A" o "B"**  

**SQL Incorrecto (No funciona en MySQL con `LIKE`):**  

```sql
SELECT * FROM alumnos WHERE nombre LIKE '[A-B]%';
```

‚úÖ **Correcci√≥n con `REGEXP`:**  

```sql
SELECT * FROM alumnos WHERE nombre REGEXP '^[A-B]';
```

üîπ **Explicaci√≥n:**  

- `^` ‚Üí Indica que la coincidencia debe estar al **inicio** del nombre.  
- `[A-B]` ‚Üí Acepta nombres que **empiecen con "A" o "B"**.  

---

### **2Ô∏è‚É£ Buscar alumnos cuyos nombres comiencen con "A" o "M" y contengan "del" en cualquier parte**  

**SQL Incorrecto (No funciona en MySQL con `LIKE`):**  

```sql
SELECT * FROM alumnos WHERE first_name LIKE '[AM]%del%';
```

‚úÖ **Correcci√≥n con `REGEXP`:**  

```sql
SELECT * FROM alumnos WHERE nombre REGEXP '^[AM].*del.*';
```

üîπ **Explicaci√≥n:**  

- `^[AM]` ‚Üí **Empieza con "A" o "M"**.  
- `.*del.*` ‚Üí Contiene **"del" en cualquier parte** del nombre.  

---

### **3Ô∏è‚É£ Buscar alumnos cuyos nombres NO empiecen con "D" o "V"**  

**SQL Incorrecto (No funciona en MySQL con `LIKE`):**  

```sql
SELECT * FROM alumnos WHERE name LIKE '[^DV]%';
```

‚úÖ **Correcci√≥n con `REGEXP`:**  

```sql
SELECT * FROM alumnos WHERE nombre REGEXP '^[^DV]';
```

üîπ **Explicaci√≥n:**  

- `^` **dentro de los corchetes (`[^DV]`)** ‚Üí Niega los caracteres dentro, es decir, **excluye los nombres que comiencen con "D" o "V"**.  

---

## **üìå Resumen de la conversi√≥n de `LIKE` a `REGEXP` en MySQL**  

| **Consulta original (`LIKE` en SQL Server)** | **Conversi√≥n correcta (`REGEXP` en MySQL)** |
|---------------------------------|---------------------------------|
| `LIKE '[A-B]%'` | `REGEXP '^[A-B]'` |
| `LIKE '[AM]%del%'` | `REGEXP '^[AM].*del.*'` |
| `LIKE '[^DV]%'` | `REGEXP '^[^DV]'` |

‚úÖ **Usa `LIKE` para b√∫squedas simples con `%`.**  
‚úÖ **Usa `REGEXP` para b√∫squedas avanzadas con rangos `[ ]`, negaciones `[^ ]` y patrones m√°s complejos.**  

## **üìå 6. Conclusi√≥n**

‚úÖ **`REGEXP` es una herramienta poderosa** que permite hacer b√∫squedas avanzadas, validaciones y limpieza de datos en MySQL.  
‚úÖ **Es m√°s flexible que `LIKE`**, pero puede ser m√°s costoso en t√©rminos de rendimiento en grandes vol√∫menes de datos.  
‚úÖ **Usar `REGEXP` es clave para validar formatos**, como correos electr√≥nicos, n√∫meros de tel√©fono o c√≥digos espec√≠ficos.

5. **Subconsultas en SQL**
   - üìñ **Concepto:** Consultas dentro de consultas.
   - üîç **Tipos de Subconsultas:**
     - **Escalar** (devuelve un solo valor)
     - **Multifila** (`IN`, `EXISTS`)
   - ‚úÖ **Ejemplo de Aplicaci√≥n:**

     ```sql
     SELECT nombre, apellido
     FROM alumnos
     WHERE id_alumno IN (SELECT id_alumno FROM inscripciones);
     ```

---

### **üïí Funciones y Sentencias Avanzadas**

6. **Combinaci√≥n de Subconsultas y Funciones**

   - üìñ **Concepto:** Se pueden usar funciones dentro de subconsultas para c√°lculos din√°micos.
   - ‚úÖ **Ejemplo de Aplicaci√≥n:**

     ```sql
     SELECT nombre, apellido, edad
     FROM alumnos
     WHERE edad = (SELECT MAX(edad) FROM alumnos);
     ```

# **üìå Combinaci√≥n de Subconsultas y Funciones en MySQL**

En MySQL, podemos **combinar subconsultas con funciones** para obtener informaci√≥n m√°s compleja y √∫til. Esto nos permite realizar c√°lculos, filtrar datos din√°micamente y mejorar la eficiencia de nuestras consultas.

---

## **üßê 1. ¬øQu√© es una subconsulta?**

Una **subconsulta** es una consulta dentro de otra consulta. Puede usarse en **cl√°usulas `SELECT`, `WHERE`, `HAVING` o `FROM`** para devolver datos que ser√°n utilizados por la consulta principal.

**Ejemplo b√°sico:**

```sql
SELECT nombre, edad
FROM alumnos
WHERE edad = (SELECT MAX(edad) FROM alumnos);
```

üîπ **Encuentra el alumno con la mayor edad.**

---

## **üîπ 2. Tipos de Subconsultas**

Las subconsultas pueden ser:

1. **Escalares** ‚Üí Devuelven un solo valor.
2. **De una sola columna** ‚Üí Devuelven varios valores en una columna.
3. **De varias columnas** ‚Üí Devuelven varias filas y columnas.
4. **Correlacionadas** ‚Üí Se ejecutan por cada fila de la consulta principal.

Ejemplo de subconsulta **escalar** con funciones:

```sql
SELECT nombre, edad
FROM alumnos
WHERE edad > (SELECT AVG(edad) FROM alumnos);
```

üîπ **Lista los alumnos cuya edad es mayor al promedio.**

---

## **üéØ 3. Funciones Combinadas con Subconsultas**

### **üîπ Funciones de Agregaci√≥n + Subconsultas**

Las funciones de agregaci√≥n (`SUM()`, `AVG()`, `COUNT()`, `MIN()`, `MAX()`) son ideales para calcular valores a partir de subconsultas.

#### üìå **Ejemplo 1: Obtener el alumno m√°s joven por nacionalidad**

```sql
SELECT nombre, nacionalidad, edad
FROM alumnos
WHERE (nacionalidad, edad) IN (
    SELECT nacionalidad, MIN(edad)
    FROM alumnos
    GROUP BY nacionalidad
);
```

üîπ **Encuentra el alumno m√°s joven de cada pa√≠s.**

---

### **üîπ Funciones de Texto + Subconsultas**

Podemos transformar datos con funciones de cadena (`CONCAT()`, `UPPER()`, `LOWER()`, `SUBSTRING()`).

#### üìå **Ejemplo 2: Obtener emails en may√∫sculas de alumnos mayores al promedio de edad**

```sql
SELECT UPPER(email) AS email_mayuscula
FROM alumnos
WHERE edad > (SELECT AVG(edad) FROM alumnos);
```

üîπ **Convierte en may√∫sculas los emails de los alumnos con edad mayor al promedio.**

---

### **üîπ Funciones de Fecha + Subconsultas**

Las funciones de fecha (`NOW()`, `DATEDIFF()`, `YEAR()`, `MONTH()`) permiten calcular tiempos.

#### üìå **Ejemplo 3: Alumnos que se inscribieron hace m√°s de 1 a√±o**

```sql
SELECT nombre, fecha_inscripcion
FROM alumnos
WHERE DATEDIFF(NOW(), fecha_inscripcion) > 365;
```

üîπ **Muestra los alumnos que se inscribieron hace m√°s de un a√±o.**

---

## **üìå 4. Subconsultas en la Cl√°usula `FROM`**

Podemos usar una subconsulta como una **tabla temporal** dentro del `FROM`.

#### üìå **Ejemplo 4: Promedio de edad por nacionalidad**

```sql
SELECT nacionalidad, promedio_edad
FROM (
    SELECT nacionalidad, AVG(edad) AS promedio_edad
    FROM alumnos
    GROUP BY nacionalidad
) AS subconsulta
ORDER BY promedio_edad DESC;
```

üîπ **Calcula el promedio de edad por nacionalidad y los ordena de mayor a menor.**

---

## **üìå 5. Subconsultas Correlacionadas**

Las **subconsultas correlacionadas** dependen de la consulta principal y se ejecutan para cada fila.

#### üìå **Ejemplo 5: Obtener alumnos cuya edad sea mayor que la edad promedio de su nacionalidad**

```sql
SELECT nombre, nacionalidad, edad
FROM alumnos A
WHERE edad > (SELECT AVG(edad) FROM alumnos WHERE nacionalidad = A.nacionalidad);
```

üîπ **Compara la edad de cada alumno con el promedio de su propio pa√≠s.**

---

## **üìå 6. Combinaci√≥n de Subconsultas con Operadores (`IN`, `NOT IN`, `EXISTS`)**

### **üîπ `IN` con Subconsultas**

```sql
SELECT nombre, email
FROM alumnos
WHERE nacionalidad IN (SELECT nacionalidad FROM alumnos WHERE edad > 30);
```

üîπ **Lista los alumnos de pa√≠ses donde hay personas mayores de 30 a√±os.**

### **üîπ `EXISTS` con Subconsultas**

```sql
SELECT nombre
FROM alumnos A
WHERE EXISTS (
    SELECT 1 FROM alumnos B WHERE B.nacionalidad = A.nacionalidad AND B.edad > 30
);
```

üîπ **Muestra los alumnos que pertenecen a una nacionalidad donde hay mayores de 30 a√±os.**

---

## **üìå 7. Conclusi√≥n**

‚úÖ **Las subconsultas permiten construir consultas m√°s complejas y din√°micas.**  
‚úÖ **Combinarlas con funciones agrega m√°s poder y flexibilidad a los an√°lisis de datos.**  
‚úÖ **Son √∫tiles para c√°lculos, validaciones y transformaciones de datos.**

7. **Data Definition Language (DDL)**

   - üìñ **Concepto:** Instrucciones que modifican la estructura de la base de datos (`CREATE`, `DROP`, `ALTER`, `TRUNCATE`).
   - ‚úÖ **Ejemplo de Aplicaci√≥n:**

     ```sql
     ALTER TABLE alumnos ADD COLUMN direccion VARCHAR(100);
     ```

## **üìå Data Definition Language (DDL) en MySQL**

El **Data Definition Language (DDL)** es una parte fundamental de SQL que se utiliza para **definir y gestionar la estructura de las bases de datos**. Con DDL, podemos crear, modificar y eliminar bases de datos, tablas, √≠ndices y otros objetos.

---

## **üìå 1. ¬øQu√© es DDL?**

DDL (Lenguaje de Definici√≥n de Datos) **define la estructura** de la base de datos, pero no manipula los datos directamente.

**üìå Principales comandos DDL:**  

| Comando | Descripci√≥n |
|---------|------------|
| `CREATE` | Crea bases de datos, tablas, √≠ndices, vistas, etc. |
| `ALTER` | Modifica la estructura de una tabla existente. |
| `DROP` | Elimina bases de datos, tablas o √≠ndices. |
| `TRUNCATE` | Elimina todos los datos de una tabla, pero mantiene su estructura. |
| `RENAME` | Cambia el nombre de una tabla. |

---

## **üìå 2. Comando `CREATE`**

Se usa para **crear** bases de datos, tablas, √≠ndices y otros objetos.

### **üìå Crear una Base de Datos**

```sql
CREATE DATABASE IF NOT EXISTS escuela;
```

üîπ **Crea una base de datos llamada `escuela` si no existe.**

### **üìå Crear una Tabla**

```sql
CREATE TABLE alumnos (
    id_alumno INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(50) NOT NULL,
    apellido VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    edad INT CHECK (edad >= 0),
    fecha_inscripcion DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

üîπ **Crea la tabla `alumnos` con diversas restricciones como `PRIMARY KEY`, `UNIQUE` y `CHECK`.**

---

## **üìå 3. Comando `ALTER`**

Se usa para **modificar** la estructura de una tabla existente.

### **üìå Agregar una columna**

```sql
ALTER TABLE alumnos ADD COLUMN telefono VARCHAR(20);
```

üîπ **A√±ade la columna `telefono` a la tabla `alumnos`.**

### **üìå Modificar una columna**

```sql
ALTER TABLE alumnos MODIFY COLUMN telefono VARCHAR(15) NOT NULL;
```

üîπ **Modifica el tipo de dato y agrega `NOT NULL`.**

### **üìå Renombrar una columna**

```sql
ALTER TABLE alumnos CHANGE COLUMN telefono celular VARCHAR(15);
```

üîπ **Cambia el nombre de `telefono` a `celular`.**

### **üìå Eliminar una columna**

```sql
ALTER TABLE alumnos DROP COLUMN edad;
```

üîπ **Elimina la columna `edad`.**

---

## **üìå 4. Comando `DROP`**

Se usa para **eliminar** bases de datos, tablas o columnas.

### **üìå Eliminar una Tabla**

```sql
DROP TABLE IF EXISTS alumnos;
```

üîπ **Elimina la tabla `alumnos` si existe.**

### **üìå Eliminar una Base de Datos**

```sql
DROP DATABASE IF EXISTS escuela;
```

üîπ **Elimina la base de datos `escuela`.**

---

## **üìå 5. Comando `TRUNCATE`**

Elimina **todos los datos** de una tabla pero mantiene su estructura.

```sql
TRUNCATE TABLE alumnos;
```

üîπ **Vac√≠a la tabla `alumnos`, pero no la elimina.**

‚ö†Ô∏è **Diferencias entre `DELETE` y `TRUNCATE`:**  

| `DELETE` | `TRUNCATE` |
|----------|-----------|
| Puede eliminar filas espec√≠ficas con `WHERE`. | Elimina todos los registros de la tabla. |
| M√°s lento porque registra cada eliminaci√≥n. | M√°s r√°pido porque no registra cada eliminaci√≥n. |
| Puede activar triggers. | No activa triggers. |

---

## **üìå 6. Comando `RENAME`**

Cambia el nombre de una tabla.

```sql
RENAME TABLE alumnos TO estudiantes;
```

üîπ **Renombra `alumnos` a `estudiantes`.**

---

## **üìå 7. Resumen**

‚úÖ **DDL define la estructura** de la base de datos.  
‚úÖ **No manipula datos, solo objetos** (tablas, √≠ndices, etc.).  
‚úÖ **Comandos principales:** `CREATE`, `ALTER`, `DROP`, `TRUNCATE`, `RENAME`.  
‚úÖ **`TRUNCATE` es m√°s r√°pido que `DELETE` para eliminar todos los registros.**

8. **Sentencias de Manipulaci√≥n de Objetos**

   - üìñ **Concepto:** Comandos para modificar objetos de la base de datos.
   - ‚úÖ **Ejemplo de Aplicaci√≥n:**

     ```sql
     DROP TABLE inscripciones;
     TRUNCATE TABLE alumnos;
     ```

9. **Funciones Escalares en MySQL**

   - üìñ **Concepto:** Funciones que operan sobre valores individuales.
   - üîç **Ejemplos:**
     - **Funciones de cadena:** `CONCAT()`, `UCASE()`, `LCASE()`, `REVERSE()`
     - **Funciones num√©ricas:** `ROUND()`, `CEIL()`, `FLOOR()`, `ABS()`
     - **Funciones de fecha:** `NOW()`, `CURDATE()`, `YEAR()`, `MONTH()`
   - ‚úÖ **Ejemplo de Aplicaci√≥n:**

     ```sql
     SELECT CONCAT(nombre, ' ', apellido) AS nombre_completo FROM alumnos;
     SELECT UCASE(nombre) FROM alumnos;
     ```

## **üìå Funciones Escalares en MySQL**

Las **funciones escalares** en MySQL son funciones que **operan sobre una √∫nica fila** y devuelven un **√∫nico valor** como resultado. Estas funciones se utilizan com√∫nmente para manipular y transformar datos en las consultas SQL.

---

## **üìå 1. ¬øQu√© son las funciones escalares?**

Son funciones que reciben un valor, lo procesan y devuelven otro valor. **No afectan a varias filas, sino a valores individuales.**

**Tipos principales de funciones escalares en MySQL:**

1. **Funciones de cadena** (para manipulaci√≥n de textos).
2. **Funciones num√©ricas** (para c√°lculos matem√°ticos).
3. **Funciones de fecha y hora** (para manipular fechas y horas).
4. **Funciones de conversi√≥n** (para cambiar tipos de datos).

---

## **üìå 2. Funciones de Cadena (Strings)**

Estas funciones permiten manipular valores de tipo `VARCHAR` o `TEXT`.

### üîπ **`UPPER()` y `LOWER()` ‚Äì Convertir a may√∫sculas y min√∫sculas**

```sql
SELECT UPPER('hola mundo') AS mayusculas;  -- Resultado: HOLA MUNDO
SELECT LOWER('HOLA MUNDO') AS minusculas;  -- Resultado: hola mundo
```

### üîπ **`CONCAT()` ‚Äì Concatenar cadenas**

```sql
SELECT CONCAT('Hola', ' ', 'Mundo') AS saludo;  -- Resultado: Hola Mundo
```

### üîπ **`SUBSTRING()` ‚Äì Extraer parte de una cadena**

```sql
SELECT SUBSTRING('CoderHouse', 1, 5) AS subcadena;  -- Resultado: Coder
```

### üîπ **`LENGTH()` ‚Äì Obtener la longitud de una cadena**

```sql
SELECT LENGTH('CoderHouse') AS longitud;  -- Resultado: 10
```

### üîπ **`TRIM()` ‚Äì Eliminar espacios en blanco**

```sql
SELECT TRIM('  Hola Mundo   ') AS sin_espacios;  -- Resultado: Hola Mundo
```

### üîπ **`REVERSE()` ‚Äì Invertir una cadena**

```sql
SELECT REVERSE('CoderHouse') AS invertido;  -- Resultado: esuoHredoC
```

---

## **üìå 3. Funciones Num√©ricas**

Se utilizan para realizar c√°lculos matem√°ticos sobre valores num√©ricos.

### üîπ **Operaciones Matem√°ticas**

```sql
SELECT 10 + 5 AS suma, 10 - 5 AS resta, 10 * 5 AS multiplicacion, 10 / 5 AS division;
```

### üîπ **`ROUND()` ‚Äì Redondear un n√∫mero**

```sql
SELECT ROUND(3.14159, 2) AS redondeado;  -- Resultado: 3.14
```

### üîπ **`CEIL()` y `FLOOR()` ‚Äì Redondear hacia arriba o abajo**

```sql
SELECT CEIL(4.2) AS techo, FLOOR(4.8) AS piso;  -- Resultado: techo = 5, piso = 4
```

### üîπ **`MOD()` ‚Äì Obtener el m√≥dulo (resto de divisi√≥n)**

```sql
SELECT MOD(10, 3) AS modulo;  -- Resultado: 1
```

---

## **üìå 4. Funciones de Fecha y Hora**

Se utilizan para manipular valores de tipo `DATE`, `DATETIME` y `TIMESTAMP`.

### üîπ **`NOW()` ‚Äì Obtener la fecha y hora actual**

```sql
SELECT NOW() AS fecha_hora_actual;
```

### üîπ **`CURDATE()` y `CURTIME()` ‚Äì Obtener la fecha y la hora actual por separado**

```sql
SELECT CURDATE() AS fecha_actual, CURTIME() AS hora_actual;
```

### üîπ **`YEAR()`, `MONTH()`, `DAY()` ‚Äì Extraer partes de una fecha**

```sql
SELECT YEAR(NOW()) AS anio, MONTH(NOW()) AS mes, DAY(NOW()) AS dia;
```

### üîπ **`DATE_FORMAT()` ‚Äì Formatear una fecha**

```sql
SELECT DATE_FORMAT(NOW(), '%d/%m/%Y') AS fecha_formateada;  -- Resultado: 22/03/2025
```

---

## **üìå 5. Funciones de Conversi√≥n**

Permiten cambiar el tipo de datos de una columna o valor.

### üîπ **`CAST()` ‚Äì Convertir tipos de datos**

```sql
SELECT CAST(123.45 AS SIGNED) AS entero;  -- Resultado: 123
SELECT CAST('2025-03-22' AS DATE) AS fecha;
```

### üîπ **`CONVERT()` ‚Äì Otra forma de conversi√≥n**

```sql
SELECT CONVERT('123.45', SIGNED) AS entero;
```

---

## **üìå 6. Uso de Funciones Escalares en una Consulta**

Imagina que tenemos la siguiente tabla `alumnos`:

| id_alumno | nombre | apellido | edad | fecha_inscripcion   |
| --------- | ------ | -------- | ---- | ------------------- |
| 1         | Juan   | P√©rez    | 25   | 2024-05-01 14:30:00 |
| 2         | Mar√≠a  | G√≥mez    | 30   | 2023-08-10 10:15:00 |

Podemos usar funciones escalares en una consulta:

```sql
SELECT
    id_alumno,
    UPPER(nombre) AS nombre_mayusculas,
    CONCAT(nombre, ' ', apellido) AS nombre_completo,
    edad + 5 AS edad_futura,
    YEAR(fecha_inscripcion) AS anio_inscripcion
FROM alumnos;
```

üîπ **Salida esperada:**  

| id_alumno | nombre_mayusculas | nombre_completo | edad_futura | anio_inscripcion |
|-----------|------------------|----------------|------------|-----------------|
| 1 | JUAN | Juan P√©rez | 30 | 2024 |
| 2 | MAR√çA | Mar√≠a G√≥mez | 35 | 2023 |

---

## **üìå 7. Resumen**

‚úÖ **Las funciones escalares trabajan con valores individuales.**  
‚úÖ **Se pueden utilizar en `SELECT`, `WHERE`, `ORDER BY` y m√°s.**  
‚úÖ **Tipos de funciones:**

- **De cadena:** `UPPER()`, `CONCAT()`, `LENGTH()`, `TRIM()`.
- **Num√©ricas:** `ROUND()`, `MOD()`, `CEIL()`, `FLOOR()`.
- **De fecha:** `NOW()`, `YEAR()`, `DATE_FORMAT()`.
- **De conversi√≥n:** `CAST()`, `CONVERT()`.

10. **Ejercicios Pr√°cticos y Cierre**

- üìå **Ejercicios de Aplicaci√≥n:**
  - Encontrar el alumno m√°s joven y el m√°s viejo.
  - Obtener la edad promedio de los alumnos de nacionalidad argentina.
  - Listar los alumnos cuyo apellido termine en "z".
- ‚úÖ **Ejemplo de Resoluci√≥n:**

  ```sql
  SELECT nombre, apellido FROM alumnos WHERE apellido LIKE '%z';
  SELECT AVG(edad) FROM alumnos WHERE nacionalidad = 'Argentina';
  ```

---

## **üì¢ Conclusi√≥n de la Clase**

- üéØ **Resumen:**

  - UNION y tipos de JOIN
  - Uso avanzado de LIKE y expresiones regulares
  - Subconsultas y combinaci√≥n con funciones
  - Manipulaci√≥n de estructuras con DDL
  - Funciones escalares en MySQL

- üìå **Tarea Opcional:**
  - Crear una nueva tabla `profesores` y relacionarla con `cursos`.
  - Implementar una consulta que liste alumnos con sus cursos y profesores.

---

## üßë‚Äçüè´ Profesor

üë®‚Äçüíª **Alejandro Daniel Di Stefano**  
üìå **Desarrollador Full Stack**  
üîó **GitHub:** [Drako01](https://github.com/Drako01)